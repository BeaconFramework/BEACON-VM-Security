package com.flexiant;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URISyntaxException;
import java.util.Properties;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;

import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;

/**
 * As the name suggests this class launches the Application. Instantiates the
 * Log4j2 and spawns threads to listen to socket continuously. Starts the
 * ScanRequestProcessor to process the requests.
 * 
 * @author mramannavar,aphee,dwhigham
 *
 */

public class ApplicationLauncher {

	private static Logger LOGGER = LogManager.getLogger(ApplicationLauncher.class);
	// private static String configFile = "log4j2.xml";

	// Once the project is being used by the other partners, the queue length
	// will be increased.
	private static int MAX_QUEUE_LENGTH = 15;
	private static ArrayBlockingQueue<Request> queue = null;
	private static ExecutorService socketThreads = null;


	public static void main(String[] args) throws URISyntaxException {

		//Load properties and ssh keys from the config file
		
		LoadProperties loadProperties = new LoadProperties();
		loadProperties.loadProperties();
		loadProperties.loadKeys();

		loadProperties.loadFCOConfig();
		loadProperties.loadOpenstackConfig();
		loadProperties.loadOpenNebulaConfig();

		//Set up queue to receive requests
		queue = new ArrayBlockingQueue<Request>(MAX_QUEUE_LENGTH);
		socketThreads = Executors.newFixedThreadPool(4);

		LOGGER.debug("The runnables being submitted, ready to read from the socket");
		socketThreads.submit(new SocketListener(Clouds.FLEX, queue));
		socketThreads.submit(new SocketListener(Clouds.OPEN_STACK, queue));
		socketThreads.submit(new SocketListener(Clouds.OPEN_NEBULA, queue));
		socketThreads.submit(new SocketListener(Clouds.AWS, queue));


		LOGGER.info("Launching the a RequestProcessor...");

		FirewallRequests req = new FirewallRequests();

		final ScanRequestProcessor processor = new ScanRequestProcessor(queue);
		processor.processRequests();

		Runtime.getRuntime().addShutdownHook(new Thread() {
			public void run() {
				LOGGER.info("Application Terminated, shutdown hook called.");
				shutdown();
				processor.shutdown();
			}
		});
	}

	public static void shutdown() {
		try {
			socketThreads.shutdown();

			while (!socketThreads.awaitTermination(60, TimeUnit.SECONDS)) {
				LOGGER.info("Awaiting for the threads to finish ...");
			}

			if (!socketThreads.isTerminated()) {
				socketThreads.shutdownNow();
			}
		} catch (InterruptedException e) {
			LOGGER.error("The newFixedThreadPool was interrupted while being shut.", e);
		}
	}
}
